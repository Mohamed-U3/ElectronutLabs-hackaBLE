import sys
import argparse
from PIL import Image
import subprocess
from subprocess import Popen, PIPE

# compress given image from N*N to N*N/8 - B & W image
def compress_bw(img_in, image_width, image_height):
    img_out = []

    length = image_width*image_height

    for i in range(0, length, 8):
        # 8 values go into one byte
        val = 0xff
        no_of_bytes = 8
        if length < 8:
            no_of_bytes = length
        
        for j in range(no_of_bytes):
            val &= ~((0x1 & img_in[i+j]) << 7-j)
        # save
        img_out.append(val)
        length = length-8

    return img_out

def get_image_width(img_path):
    process = Popen('exiftool ' + img_path + ' -ImageWidth -b', shell=True, stdout=PIPE, stderr=PIPE)
    stdout, stderr = process.communicate()
    
    if not stderr:
        return stdout
    else:
        return -1

def get_image_height(img_path):
    process = Popen('exiftool ' + img_path + ' -ImageHeight -b', shell=True, stdout=PIPE, stderr=PIPE)
    stdout, stderr = process.communicate()
    
    if not stderr:
        return stdout
    else:
        return -1

# print compress image to c array in a file
def print_img(imgc_bw, imgc_red, header_file_name, image_name, image_width, image_height):
    # open header file
    f = open(header_file_name, 'w')

    hdr_comment = r"""/*
image.h

Compressed image data for e-ink display.

Generated by Python.
*/
"""
    # f.write(hdr_comment)

    f.write("module.exports = {\n")
    # workaround
    f.write(image_name + "_image_width: "+str(image_height)+",\n")
    f.write(image_name + "_image_height: "+str(image_width)+",\n")

    # write BW data
    f.write(image_name + "_bwData: [")
    for i in range(len(imgc_bw)):
        f.write("'0x%x'," % imgc_bw[i])
    f.write("\n]")
    f.write("\n}")

    f.write("\n")
    
    # write red data
    # f.write("const unsigned char " + image_name + "_redData[] = {")
    # for i in range(len(imgc_red)):
    #     f.write("0x%x," % imgc_red[i])
    # f.write("\n};")

    # f.write("\n\n")

    f.close()

def color_no_frequency(pix, image_width, image_height):
    dict = {}

    for i in range(image_width):
        for j in range(image_height):
            (l, a) = pix[i, j]
            keys = dict.keys()
            if l in keys:
                dict[l] += 1
            else:
                dict[l] = 1

    return dict

# main() function
def main():

    # create parser
    descStr = """
    This program creates image headers for the GDEW0154Z04 epaper display.
    """
    parser = argparse.ArgumentParser(description=descStr)

    # add arguments
    parser.add_argument('--input-img', dest='input_img', required=True)

    # parse args
    args = parser.parse_args()

    if args.input_img:
        image_width = int(get_image_width(args.input_img))
        image_height = int(get_image_height(args.input_img))

        print("opening %s..." % args.input_img)

        image_name = args.input_img.split("/")[-1].split(".")[0].split("-")[-1]
        print "prefix :", image_name

        # open image in LA mode
        im1 = Image.open(args.input_img).convert('LA')
        # im1.show()

        print "image size :", Image.open(args.input_img).size

        # get pixel access
        pix = im1.load()

        # d = color_no_frequency(pix, image_width, image_height)

        # for key, value in d.iteritems():
        #     print key, value

        # exit(0)

        # uncompressed image data 
        image_data_bw = image_width*image_height*[0]

        # threshold and create B & W image
        for i in range(image_width):
            for j in range(image_height):
                (l, a) = pix[i, j]
                # print pix[i,j]

                if l > 128:
                    image_data_bw[i*image_height + j] = 0
                else:
                    image_data_bw[i*image_height + j] = 1             

        print("compressing b & w image...")
        # compress
        image_data_bw_c = compress_bw(image_data_bw, image_width, image_height)

        print("printing image header...")
        # print
        print_img(image_data_bw_c, [], "image.js", image_name, image_width, image_height)

        process = Popen('sudo node transfer_image.js', shell=True, stdout=PIPE, stderr=PIPE)
        stdout, stderr = process.communicate()

        print stderr
        print "-------------------------------"
        print stdout
        
        # if not stderr:
        #     print stdout
        # else:
        #     print("error while transferring image data")

        print("done")


# call main
if __name__ == '__main__':
    main()
